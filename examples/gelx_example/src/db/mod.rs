//! This file is generated by `gelx generate`.
//! It is not intended for manual editing.
//! To update it, run `gelx generate`.
#![cfg_attr(rustfmt, rustfmt_skip)]
#![allow(unused)]
#![allow(unused_qualifications)]
#![allow(clippy::all)]
use ::gelx::exports as __g;
pub use default::*;
#[path = "additional.rs"]
pub mod additional;
#[path = "default.rs"]
pub mod default;
#[derive(::std::fmt::Debug, ::core::clone::Clone, __g::typed_builder::TypedBuilder)]
#[cfg_attr(
    feature = "with_serde",
    derive(__g::serde::Serialize, __g::serde::Deserialize)
)]
#[cfg_attr(feature = "with_query", derive(__g::gel_derive::Queryable))]
#[builder(crate_module_path = __g::typed_builder)]
#[cfg_attr(feature = "with_query", gel(crate_path = __g::gel_protocol))]
#[builder(field_defaults(default, setter(into, strip_option(fallback_suffix = "_opt"))))]
pub struct Globals {
    pub client_token: Option<String>,
    pub alternative: Option<String>,
    pub current_user_id: Option<__g::uuid::Uuid>,
}
#[cfg(feature = "with_query")]
impl __g::gel_tokio::GlobalsDelta for Globals {
    fn apply(self, modifier: &mut __g::gel_tokio::state::GlobalsModifier<'_>) {
        modifier.set("ext::auth::client_token", self.client_token);
        modifier.set("additional::alternative", self.alternative);
        modifier.set("default::current_user_id", self.current_user_id);
    }
}
#[cfg(feature = "with_query")]
impl Globals {
    /// Create a gel client with the globals.
    pub async fn into_client(
        self,
    ) -> ::core::result::Result<__g::gel_tokio::Client, __g::gel_tokio::Error> {
        let client = __g::gel_tokio::create_client().await?.with_globals(self);
        Ok(client)
    }
    /// Create a gel client with the globals.
    pub async fn to_client(
        &self,
    ) -> ::core::result::Result<__g::gel_tokio::Client, __g::gel_tokio::Error> {
        let client = self.clone().into_client().await?;
        Ok(client)
    }
}
pub mod auth_allowed_redirect_urls {
    use ::gelx::exports as __g;
    /// Execute the desired query.
    #[cfg(feature = "with_query")]
    pub async fn query(
        client: impl __g::gel_tokio::QueryExecutor,
    ) -> ::core::result::Result<(), __g::gel_errors::Error> {
        client.execute(QUERY, &()).await
    }
    pub type Input = ();
    pub type Output = ();
    /// The original query string provided to the macro. Can be reused in your codebase.
    pub const QUERY: &str = "# This query is used to set the allowed redirect URLs for the auth system. Unfortunately,\n# `configure` can't be used with parameters.\n#\n# `non-constant expression in CONFIGURE DATABASE SET`\nconfigure current branch set ext::auth::AuthConfig::allowed_redirect_urls := {\n    'https://example.com',\n    'https://example.com/auth',\n    'https://localhost:3000',\n    'https://localhost:3000/auth'\n};\n";
}
pub mod insert_location {
    use ::gelx::exports as __g;
    /// Execute the desired query.
    #[cfg(feature = "with_query")]
    pub async fn query(
        client: impl __g::gel_tokio::QueryExecutor,
        props: &Input,
    ) -> ::core::result::Result<Output, __g::gel_errors::Error> {
        client.query_required_single(QUERY, props).await
    }
    #[derive(::std::fmt::Debug, ::core::clone::Clone, __g::typed_builder::TypedBuilder)]
    #[cfg_attr(
        feature = "with_serde",
        derive(__g::serde::Serialize, __g::serde::Deserialize)
    )]
    #[cfg_attr(feature = "with_query", derive(__g::gel_derive::Queryable))]
    #[builder(crate_module_path = __g::typed_builder)]
    #[cfg_attr(feature = "with_query", gel(crate_path = __g::gel_protocol))]
    pub struct Input {
        #[builder(setter(into))]
        pub point: __g::Geometry,
        #[builder(setter(into))]
        pub area: __g::Geography,
    }
    impl __g::gel_protocol::query_arg::QueryArgs for Input {
        fn encode(
            &self,
            encoder: &mut __g::gel_protocol::query_arg::Encoder,
        ) -> core::result::Result<(), __g::gel_errors::Error> {
            let map = __g::gel_protocol::named_args! {
                "point" => self.point.clone(), "area" => self.area.clone(),
            };
            map.encode(encoder)
        }
    }
    #[derive(::std::fmt::Debug, ::core::clone::Clone)]
    #[cfg_attr(
        feature = "with_serde",
        derive(__g::serde::Serialize, __g::serde::Deserialize)
    )]
    #[cfg_attr(feature = "with_query", derive(__g::gel_derive::Queryable))]
    #[cfg_attr(feature = "with_query", gel(crate_path = __g::gel_protocol))]
    pub struct Output {
        pub point: __g::Geometry,
        pub area: __g::Geography,
    }
    /// The original query string provided to the macro. Can be reused in your codebase.
    pub const QUERY: &str = "with NewLocation := (insert Location {\n\tpoint := <ext::postgis::geometry>$point,\n\tarea := <ext::postgis::geography>$area,\n})\nselect NewLocation {\n\tpoint,\n\tarea,\n};";
}
pub mod insert_position {
    use ::gelx::exports as __g;
    /// Execute the desired query.
    #[cfg(feature = "with_query")]
    pub async fn query(
        client: impl __g::gel_tokio::QueryExecutor,
        props: &Input,
    ) -> ::core::result::Result<Output, __g::gel_errors::Error> {
        client.query_required_single(QUERY, props).await
    }
    #[derive(::std::fmt::Debug, ::core::clone::Clone, __g::typed_builder::TypedBuilder)]
    #[cfg_attr(
        feature = "with_serde",
        derive(__g::serde::Serialize, __g::serde::Deserialize)
    )]
    #[cfg_attr(feature = "with_query", derive(__g::gel_derive::Queryable))]
    #[builder(crate_module_path = __g::typed_builder)]
    #[cfg_attr(feature = "with_query", gel(crate_path = __g::gel_protocol))]
    pub struct Input {
        #[builder(setter(into))]
        pub position: super::default::Position,
    }
    impl __g::gel_protocol::query_arg::QueryArgs for Input {
        fn encode(
            &self,
            encoder: &mut __g::gel_protocol::query_arg::Encoder,
        ) -> core::result::Result<(), __g::gel_errors::Error> {
            let map = __g::gel_protocol::named_args! {
                "position" => self.position.clone(),
            };
            map.encode(encoder)
        }
    }
    #[derive(::std::fmt::Debug, ::core::clone::Clone)]
    #[cfg_attr(
        feature = "with_serde",
        derive(__g::serde::Serialize, __g::serde::Deserialize)
    )]
    #[cfg_attr(feature = "with_query", derive(__g::gel_derive::Queryable))]
    #[cfg_attr(feature = "with_query", gel(crate_path = __g::gel_protocol))]
    pub struct Output {
        pub id: __g::uuid::Uuid,
        pub position: super::default::Position,
    }
    /// The original query string provided to the macro. Can be reused in your codebase.
    pub const QUERY: &str = "select (insert Simple {\n  position := <default::Position>$position,\n}) {**};\n";
}
pub mod insert_user {
    use ::gelx::exports as __g;
    /// Execute the desired query.
    #[cfg(feature = "with_query")]
    pub async fn query(
        client: impl __g::gel_tokio::QueryExecutor,
        props: &Input,
    ) -> ::core::result::Result<Output, __g::gel_errors::Error> {
        client.query_required_single(QUERY, props).await
    }
    #[derive(::std::fmt::Debug, ::core::clone::Clone, __g::typed_builder::TypedBuilder)]
    #[cfg_attr(
        feature = "with_serde",
        derive(__g::serde::Serialize, __g::serde::Deserialize)
    )]
    #[cfg_attr(feature = "with_query", derive(__g::gel_derive::Queryable))]
    #[builder(crate_module_path = __g::typed_builder)]
    #[cfg_attr(feature = "with_query", gel(crate_path = __g::gel_protocol))]
    pub struct Input {
        #[builder(setter(into))]
        pub name: String,
        #[builder(setter(into))]
        pub bio: String,
        #[builder(setter(into))]
        pub slug: String,
    }
    impl __g::gel_protocol::query_arg::QueryArgs for Input {
        fn encode(
            &self,
            encoder: &mut __g::gel_protocol::query_arg::Encoder,
        ) -> core::result::Result<(), __g::gel_errors::Error> {
            let map = __g::gel_protocol::named_args! {
                "name" => self.name.clone(), "bio" => self.bio.clone(), "slug" => self
                .slug.clone(),
            };
            map.encode(encoder)
        }
    }
    #[derive(::std::fmt::Debug, ::core::clone::Clone)]
    #[cfg_attr(
        feature = "with_serde",
        derive(__g::serde::Serialize, __g::serde::Deserialize)
    )]
    #[cfg_attr(feature = "with_query", derive(__g::gel_derive::Queryable))]
    #[cfg_attr(feature = "with_query", gel(crate_path = __g::gel_protocol))]
    pub struct Output {
        pub id: __g::uuid::Uuid,
        pub name: Option<String>,
        pub bio: Option<String>,
        pub slug: String,
    }
    /// The original query string provided to the macro. Can be reused in your codebase.
    pub const QUERY: &str = "select (insert User {\n  name := <str>$name,\n  bio := <str>$bio,\n  slug := <str>$slug,\n}) {\n  id,\n  name,\n  bio,\n  slug,\n};\n";
}
pub mod remove_user {
    use ::gelx::exports as __g;
    /// Execute the desired query.
    #[cfg(feature = "with_query")]
    pub async fn query(
        client: impl __g::gel_tokio::QueryExecutor,
        props: &Input,
    ) -> ::core::result::Result<Option<Output>, __g::gel_errors::Error> {
        client.query_single(QUERY, props).await
    }
    #[derive(::std::fmt::Debug, ::core::clone::Clone, __g::typed_builder::TypedBuilder)]
    #[cfg_attr(
        feature = "with_serde",
        derive(__g::serde::Serialize, __g::serde::Deserialize)
    )]
    #[cfg_attr(feature = "with_query", derive(__g::gel_derive::Queryable))]
    #[builder(crate_module_path = __g::typed_builder)]
    #[cfg_attr(feature = "with_query", gel(crate_path = __g::gel_protocol))]
    pub struct Input {
        #[builder(setter(into))]
        pub id: __g::uuid::Uuid,
    }
    impl __g::gel_protocol::query_arg::QueryArgs for Input {
        fn encode(
            &self,
            encoder: &mut __g::gel_protocol::query_arg::Encoder,
        ) -> core::result::Result<(), __g::gel_errors::Error> {
            let map = __g::gel_protocol::named_args! {
                "id" => self.id.clone(),
            };
            map.encode(encoder)
        }
    }
    #[derive(::std::fmt::Debug, ::core::clone::Clone)]
    #[cfg_attr(
        feature = "with_serde",
        derive(__g::serde::Serialize, __g::serde::Deserialize)
    )]
    #[cfg_attr(feature = "with_query", derive(__g::gel_derive::Queryable))]
    #[cfg_attr(feature = "with_query", gel(crate_path = __g::gel_protocol))]
    pub struct Output {
        pub id: __g::uuid::Uuid,
    }
    /// The original query string provided to the macro. Can be reused in your codebase.
    pub const QUERY: &str = "delete User filter .id = <uuid>$id;\n";
}
pub mod select_accounts {
    use ::gelx::exports as __g;
    /// Execute the desired query.
    #[cfg(feature = "with_query")]
    pub async fn query(
        client: impl __g::gel_tokio::QueryExecutor,
        props: &Input,
    ) -> ::core::result::Result<Vec<Output>, __g::gel_errors::Error> {
        client.query(QUERY, props).await
    }
    #[derive(::std::fmt::Debug, ::core::clone::Clone, __g::typed_builder::TypedBuilder)]
    #[cfg_attr(
        feature = "with_serde",
        derive(__g::serde::Serialize, __g::serde::Deserialize)
    )]
    #[cfg_attr(feature = "with_query", derive(__g::gel_derive::Queryable))]
    #[builder(crate_module_path = __g::typed_builder)]
    #[cfg_attr(feature = "with_query", gel(crate_path = __g::gel_protocol))]
    pub struct Input {
        #[builder(setter(into))]
        pub provider: super::default::AccountProvider,
    }
    impl __g::gel_protocol::query_arg::QueryArgs for Input {
        fn encode(
            &self,
            encoder: &mut __g::gel_protocol::query_arg::Encoder,
        ) -> core::result::Result<(), __g::gel_errors::Error> {
            let map = __g::gel_protocol::named_args! {
                "provider" => self.provider.clone(),
            };
            map.encode(encoder)
        }
    }
    #[derive(::std::fmt::Debug, ::core::clone::Clone)]
    #[cfg_attr(
        feature = "with_serde",
        derive(__g::serde::Serialize, __g::serde::Deserialize)
    )]
    #[cfg_attr(feature = "with_query", derive(__g::gel_derive::Queryable))]
    #[cfg_attr(feature = "with_query", gel(crate_path = __g::gel_protocol))]
    pub struct OutputUser {
        pub slug: String,
        pub id: __g::uuid::Uuid,
        pub created_at: __g::DateTimeAlias,
        pub updated_at: __g::DateTimeAlias,
        pub bio: Option<String>,
        pub name: Option<String>,
    }
    #[derive(::std::fmt::Debug, ::core::clone::Clone)]
    #[cfg_attr(
        feature = "with_serde",
        derive(__g::serde::Serialize, __g::serde::Deserialize)
    )]
    #[cfg_attr(feature = "with_query", derive(__g::gel_derive::Queryable))]
    #[cfg_attr(feature = "with_query", gel(crate_path = __g::gel_protocol))]
    pub struct Output {
        pub access_token: Option<String>,
        pub access_token_expires_at: Option<__g::DateTimeAlias>,
        pub created_at: __g::DateTimeAlias,
        pub id: __g::uuid::Uuid,
        pub updated_at: __g::DateTimeAlias,
        pub provider: super::default::AccountProvider,
        pub provider_account_id: String,
        pub refresh_token: Option<String>,
        pub refresh_token_expires_at: Option<__g::DateTimeAlias>,
        pub scope: Option<String>,
        pub username: Option<String>,
        pub user: OutputUser,
    }
    /// The original query string provided to the macro. Can be reused in your codebase.
    pub const QUERY: &str = "select Account {**} filter .provider = <AccountProvider>$provider;";
}
pub mod select_test_user {
    use ::gelx::exports as __g;
    /// Execute the desired query.
    #[cfg(feature = "with_query")]
    pub async fn query(
        client: impl __g::gel_tokio::QueryExecutor,
        props: &Input,
    ) -> ::core::result::Result<Option<Output>, __g::gel_errors::Error> {
        client.query_single(QUERY, props).await
    }
    #[derive(::std::fmt::Debug, ::core::clone::Clone, __g::typed_builder::TypedBuilder)]
    #[cfg_attr(
        feature = "with_serde",
        derive(__g::serde::Serialize, __g::serde::Deserialize)
    )]
    #[cfg_attr(feature = "with_query", derive(__g::gel_derive::Queryable))]
    #[builder(crate_module_path = __g::typed_builder)]
    #[cfg_attr(feature = "with_query", gel(crate_path = __g::gel_protocol))]
    pub struct Input {
        #[builder(setter(into))]
        pub username: String,
    }
    impl __g::gel_protocol::query_arg::QueryArgs for Input {
        fn encode(
            &self,
            encoder: &mut __g::gel_protocol::query_arg::Encoder,
        ) -> core::result::Result<(), __g::gel_errors::Error> {
            let map = __g::gel_protocol::named_args! {
                "username" => self.username.clone(),
            };
            map.encode(encoder)
        }
    }
    #[derive(::std::fmt::Debug, ::core::clone::Clone)]
    #[cfg_attr(
        feature = "with_serde",
        derive(__g::serde::Serialize, __g::serde::Deserialize)
    )]
    #[cfg_attr(feature = "with_query", derive(__g::gel_derive::Queryable))]
    #[cfg_attr(feature = "with_query", gel(crate_path = __g::gel_protocol))]
    pub struct Output {
        pub id: __g::uuid::Uuid,
        pub public_id: super::default::UserId,
    }
    /// The original query string provided to the macro. Can be reused in your codebase.
    pub const QUERY: &str = "select assert_single((\n\tselect TestUser { id, public_id } filter .active and .namelc = str_lower(<str>$username)\n))\n";
}
pub mod select_user {
    use ::gelx::exports as __g;
    /// Execute the desired query.
    #[cfg(feature = "with_query")]
    pub async fn query(
        client: impl __g::gel_tokio::QueryExecutor,
        props: &Input,
    ) -> ::core::result::Result<Option<Output>, __g::gel_errors::Error> {
        client.query_single(QUERY, props).await
    }
    #[derive(::std::fmt::Debug, ::core::clone::Clone, __g::typed_builder::TypedBuilder)]
    #[cfg_attr(
        feature = "with_serde",
        derive(__g::serde::Serialize, __g::serde::Deserialize)
    )]
    #[cfg_attr(feature = "with_query", derive(__g::gel_derive::Queryable))]
    #[builder(crate_module_path = __g::typed_builder)]
    #[cfg_attr(feature = "with_query", gel(crate_path = __g::gel_protocol))]
    pub struct Input {
        #[builder(setter(into))]
        pub slug: String,
    }
    impl __g::gel_protocol::query_arg::QueryArgs for Input {
        fn encode(
            &self,
            encoder: &mut __g::gel_protocol::query_arg::Encoder,
        ) -> core::result::Result<(), __g::gel_errors::Error> {
            let map = __g::gel_protocol::named_args! {
                "slug" => self.slug.clone(),
            };
            map.encode(encoder)
        }
    }
    #[derive(::std::fmt::Debug, ::core::clone::Clone)]
    #[cfg_attr(
        feature = "with_serde",
        derive(__g::serde::Serialize, __g::serde::Deserialize)
    )]
    #[cfg_attr(feature = "with_query", derive(__g::gel_derive::Queryable))]
    #[cfg_attr(feature = "with_query", gel(crate_path = __g::gel_protocol))]
    pub struct Output {
        pub id: __g::uuid::Uuid,
        pub name: Option<String>,
        pub bio: Option<String>,
        pub slug: String,
    }
    /// The original query string provided to the macro. Can be reused in your codebase.
    pub const QUERY: &str = "select User {\n\tid,\n  name,\n  bio,\n  slug,\n} filter .slug = <str>$slug;";
}
