---
source: crates/gelx/tests/codegen.rs
expression: "&content"
---
pub mod example {
    use ::gelx::exports as __g;
    /// Execute the desired query.
    pub async fn query(
        client: impl __g::gel_tokio::QueryExecutor,
        props: &Input,
    ) -> ::core::result::Result<Vec<Output>, __g::gel_errors::Error> {
        client.query(QUERY, props).await
    }
    #[derive(::std::fmt::Debug, ::core::clone::Clone)]
    pub struct Input {
        pub amount: Option<__g::BigDecimal>,
    }
    impl __g::gel_protocol::query_arg::QueryArgs for Input {
        fn encode(
            &self,
            encoder: &mut __g::gel_protocol::query_arg::Encoder,
        ) -> core::result::Result<(), __g::gel_errors::Error> {
            let map = __g::gel_protocol::named_args! {
                "amount" => { match self.amount.clone() { Some(closure_opt_amount) => {
                Some({ let value : __g::gel_protocol::model::Decimal = closure_opt_amount
                .clone().try_into().map_err(| e | { <
                __g::gel_errors::kinds::NumericOutOfRangeError as
                __g::gel_errors::ErrorKind > ::build() }) ?; value }) }, None => None, }
                },
            };
            map.encode(encoder)
        }
    }
    #[derive(::std::fmt::Debug, ::core::clone::Clone)]
    pub struct Output {
        pub tx_hash: String,
    }
    /// The original query string provided to the macro. Can be reused in your codebase.
    pub const QUERY: &str = "with amount := <optional decimal>$amount, select Transaction {tx_hash} filter (.amount = amount if exists amount else True);";
}
