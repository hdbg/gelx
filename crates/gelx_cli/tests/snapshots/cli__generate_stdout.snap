---
source: crates/gelx_cli/tests/cli.rs
info:
  program: gelx
  args:
    - generate
    - "--json"
---
success: true
exit_code: 0
----- stdout -----
{
  "mod.rs": "//! This file is generated by `gelx generate`.\n//! It is not intended for manual editing.\n//! To update it, run `gelx generate`.\n#![cfg_attr(rustfmt, rustfmt_skip)]\n#![allow(unused)]\n#![allow(unused_qualifications)]\n#![allow(clippy::all)]\nuse ::gelx::exports as __g;\npub use default::*;\n#[path = \"additional.rs\"]\npub mod additional;\n#[path = \"default.rs\"]\npub mod default;\npub mod insert_location {\n    use ::gelx::exports as __g;\n    /// Execute the desired query.\n    #[cfg(feature = \"ssr\")]\n    pub async fn query(\n        client: &__g::gel_tokio::Client,\n        props: &Input,\n    ) -> ::core::result::Result<Output, __g::gel_errors::Error> {\n        client.query_required_single(QUERY, props).await\n    }\n    /// Compose the query as part of a larger transaction.\n    #[cfg(feature = \"ssr\")]\n    pub async fn transaction(\n        conn: &mut __g::gel_tokio::Transaction,\n        props: &Input,\n    ) -> ::core::result::Result<Output, __g::gel_errors::Error> {\n        conn.query_required_single(QUERY, props).await\n    }\n    #[derive(\n        ::std::fmt::Debug,\n        ::core::clone::Clone,\n        __g::serde::Serialize,\n        __g::serde::Deserialize,\n        __g::typed_builder::TypedBuilder\n    )]\n    #[cfg_attr(feature = \"ssr\", derive(__g::gel_derive::Queryable))]\n    pub struct Input {\n        #[builder(setter(into))]\n        pub point: __g::Geometry,\n        #[builder(setter(into))]\n        pub area: __g::Geography,\n    }\n    impl __g::gel_protocol::query_arg::QueryArgs for Input {\n        fn encode(\n            &self,\n            encoder: &mut __g::gel_protocol::query_arg::Encoder,\n        ) -> core::result::Result<(), __g::gel_errors::Error> {\n            let map = __g::gel_protocol::named_args! {\n                \"point\" => self.point.clone(), \"area\" => self.area.clone(),\n            };\n            map.encode(encoder)\n        }\n    }\n    #[derive(\n        ::std::fmt::Debug,\n        ::core::clone::Clone,\n        __g::serde::Serialize,\n        __g::serde::Deserialize\n    )]\n    #[cfg_attr(feature = \"ssr\", derive(__g::gel_derive::Queryable))]\n    pub struct Output {\n        pub point: __g::Geometry,\n        pub area: __g::Geography,\n    }\n    /// The original query string provided to the macro. Can be reused in your codebase.\n    pub const QUERY: &str = \"with NewLocation := (insert Location {\\n\\tpoint := <ext::postgis::geometry>$point,\\n\\tarea := <ext::postgis::geography>$area,\\n})\\nselect NewLocation {\\n\\tpoint,\\n\\tarea,\\n};\";\n}\npub mod insert_position {\n    use ::gelx::exports as __g;\n    /// Execute the desired query.\n    #[cfg(feature = \"ssr\")]\n    pub async fn query(\n        client: &__g::gel_tokio::Client,\n        props: &Input,\n    ) -> ::core::result::Result<Output, __g::gel_errors::Error> {\n        client.query_required_single(QUERY, props).await\n    }\n    /// Compose the query as part of a larger transaction.\n    #[cfg(feature = \"ssr\")]\n    pub async fn transaction(\n        conn: &mut __g::gel_tokio::Transaction,\n        props: &Input,\n    ) -> ::core::result::Result<Output, __g::gel_errors::Error> {\n        conn.query_required_single(QUERY, props).await\n    }\n    #[derive(\n        ::std::fmt::Debug,\n        ::core::clone::Clone,\n        __g::serde::Serialize,\n        __g::serde::Deserialize,\n        __g::typed_builder::TypedBuilder\n    )]\n    #[cfg_attr(feature = \"ssr\", derive(__g::gel_derive::Queryable))]\n    pub struct Input {\n        #[builder(setter(into))]\n        pub position: super::default::Position,\n    }\n    impl __g::gel_protocol::query_arg::QueryArgs for Input {\n        fn encode(\n            &self,\n            encoder: &mut __g::gel_protocol::query_arg::Encoder,\n        ) -> core::result::Result<(), __g::gel_errors::Error> {\n            let map = __g::gel_protocol::named_args! {\n                \"position\" => self.position.clone(),\n            };\n            map.encode(encoder)\n        }\n    }\n    #[derive(\n        ::std::fmt::Debug,\n        ::core::clone::Clone,\n        __g::serde::Serialize,\n        __g::serde::Deserialize\n    )]\n    #[cfg_attr(feature = \"ssr\", derive(__g::gel_derive::Queryable))]\n    pub struct Output {\n        pub id: __g::uuid::Uuid,\n        pub position: super::default::Position,\n    }\n    /// The original query string provided to the macro. Can be reused in your codebase.\n    pub const QUERY: &str = \"select (insert Simple {\\n  position := <default::Position>$position,\\n}) {**};\\n\";\n}\npub mod insert_user {\n    use ::gelx::exports as __g;\n    /// Execute the desired query.\n    #[cfg(feature = \"ssr\")]\n    pub async fn query(\n        client: &__g::gel_tokio::Client,\n        props: &Input,\n    ) -> ::core::result::Result<Output, __g::gel_errors::Error> {\n        client.query_required_single(QUERY, props).await\n    }\n    /// Compose the query as part of a larger transaction.\n    #[cfg(feature = \"ssr\")]\n    pub async fn transaction(\n        conn: &mut __g::gel_tokio::Transaction,\n        props: &Input,\n    ) -> ::core::result::Result<Output, __g::gel_errors::Error> {\n        conn.query_required_single(QUERY, props).await\n    }\n    #[derive(\n        ::std::fmt::Debug,\n        ::core::clone::Clone,\n        __g::serde::Serialize,\n        __g::serde::Deserialize,\n        __g::typed_builder::TypedBuilder\n    )]\n    #[cfg_attr(feature = \"ssr\", derive(__g::gel_derive::Queryable))]\n    pub struct Input {\n        #[builder(setter(into))]\n        pub name: String,\n        #[builder(setter(into))]\n        pub bio: String,\n        #[builder(setter(into))]\n        pub slug: String,\n    }\n    impl __g::gel_protocol::query_arg::QueryArgs for Input {\n        fn encode(\n            &self,\n            encoder: &mut __g::gel_protocol::query_arg::Encoder,\n        ) -> core::result::Result<(), __g::gel_errors::Error> {\n            let map = __g::gel_protocol::named_args! {\n                \"name\" => self.name.clone(), \"bio\" => self.bio.clone(), \"slug\" => self\n                .slug.clone(),\n            };\n            map.encode(encoder)\n        }\n    }\n    #[derive(\n        ::std::fmt::Debug,\n        ::core::clone::Clone,\n        __g::serde::Serialize,\n        __g::serde::Deserialize\n    )]\n    #[cfg_attr(feature = \"ssr\", derive(__g::gel_derive::Queryable))]\n    pub struct Output {\n        pub id: __g::uuid::Uuid,\n        pub name: Option<String>,\n        pub bio: Option<String>,\n        pub slug: String,\n    }\n    /// The original query string provided to the macro. Can be reused in your codebase.\n    pub const QUERY: &str = \"select (insert User {\\n  name := <str>$name,\\n  bio := <str>$bio,\\n  slug := <str>$slug,\\n}) {\\n  id,\\n  name,\\n  bio,\\n  slug,\\n};\\n\";\n}\npub mod remove_user {\n    use ::gelx::exports as __g;\n    /// Execute the desired query.\n    #[cfg(feature = \"ssr\")]\n    pub async fn query(\n        client: &__g::gel_tokio::Client,\n        props: &Input,\n    ) -> ::core::result::Result<Option<Output>, __g::gel_errors::Error> {\n        client.query_single(QUERY, props).await\n    }\n    /// Compose the query as part of a larger transaction.\n    #[cfg(feature = \"ssr\")]\n    pub async fn transaction(\n        conn: &mut __g::gel_tokio::Transaction,\n        props: &Input,\n    ) -> ::core::result::Result<Option<Output>, __g::gel_errors::Error> {\n        conn.query_single(QUERY, props).await\n    }\n    #[derive(\n        ::std::fmt::Debug,\n        ::core::clone::Clone,\n        __g::serde::Serialize,\n        __g::serde::Deserialize,\n        __g::typed_builder::TypedBuilder\n    )]\n    #[cfg_attr(feature = \"ssr\", derive(__g::gel_derive::Queryable))]\n    pub struct Input {\n        #[builder(setter(into))]\n        pub id: __g::uuid::Uuid,\n    }\n    impl __g::gel_protocol::query_arg::QueryArgs for Input {\n        fn encode(\n            &self,\n            encoder: &mut __g::gel_protocol::query_arg::Encoder,\n        ) -> core::result::Result<(), __g::gel_errors::Error> {\n            let map = __g::gel_protocol::named_args! {\n                \"id\" => self.id.clone(),\n            };\n            map.encode(encoder)\n        }\n    }\n    #[derive(\n        ::std::fmt::Debug,\n        ::core::clone::Clone,\n        __g::serde::Serialize,\n        __g::serde::Deserialize\n    )]\n    #[cfg_attr(feature = \"ssr\", derive(__g::gel_derive::Queryable))]\n    pub struct Output {\n        pub id: __g::uuid::Uuid,\n    }\n    /// The original query string provided to the macro. Can be reused in your codebase.\n    pub const QUERY: &str = \"delete User filter .id = <uuid>$id;\\n\";\n}\npub mod select_accounts {\n    use ::gelx::exports as __g;\n    /// Execute the desired query.\n    #[cfg(feature = \"ssr\")]\n    pub async fn query(\n        client: &__g::gel_tokio::Client,\n        props: &Input,\n    ) -> ::core::result::Result<Vec<Output>, __g::gel_errors::Error> {\n        client.query(QUERY, props).await\n    }\n    /// Compose the query as part of a larger transaction.\n    #[cfg(feature = \"ssr\")]\n    pub async fn transaction(\n        conn: &mut __g::gel_tokio::Transaction,\n        props: &Input,\n    ) -> ::core::result::Result<Vec<Output>, __g::gel_errors::Error> {\n        conn.query(QUERY, props).await\n    }\n    #[derive(\n        ::std::fmt::Debug,\n        ::core::clone::Clone,\n        __g::serde::Serialize,\n        __g::serde::Deserialize,\n        __g::typed_builder::TypedBuilder\n    )]\n    #[cfg_attr(feature = \"ssr\", derive(__g::gel_derive::Queryable))]\n    pub struct Input {\n        #[builder(setter(into))]\n        pub provider: super::default::AccountProvider,\n    }\n    impl __g::gel_protocol::query_arg::QueryArgs for Input {\n        fn encode(\n            &self,\n            encoder: &mut __g::gel_protocol::query_arg::Encoder,\n        ) -> core::result::Result<(), __g::gel_errors::Error> {\n            let map = __g::gel_protocol::named_args! {\n                \"provider\" => self.provider.clone(),\n            };\n            map.encode(encoder)\n        }\n    }\n    #[derive(\n        ::std::fmt::Debug,\n        ::core::clone::Clone,\n        __g::serde::Serialize,\n        __g::serde::Deserialize\n    )]\n    #[cfg_attr(feature = \"ssr\", derive(__g::gel_derive::Queryable))]\n    pub struct OutputUser {\n        pub slug: String,\n        pub id: __g::uuid::Uuid,\n        pub created_at: __g::DateTimeAlias,\n        pub updated_at: __g::DateTimeAlias,\n        pub bio: Option<String>,\n        pub name: Option<String>,\n    }\n    #[derive(\n        ::std::fmt::Debug,\n        ::core::clone::Clone,\n        __g::serde::Serialize,\n        __g::serde::Deserialize\n    )]\n    #[cfg_attr(feature = \"ssr\", derive(__g::gel_derive::Queryable))]\n    pub struct Output {\n        pub created_at: __g::DateTimeAlias,\n        pub id: __g::uuid::Uuid,\n        pub updated_at: __g::DateTimeAlias,\n        pub access_token: Option<String>,\n        pub access_token_expires_at: Option<__g::DateTimeAlias>,\n        pub provider: super::default::AccountProvider,\n        pub provider_account_id: String,\n        pub refresh_token: Option<String>,\n        pub refresh_token_expires_at: Option<__g::DateTimeAlias>,\n        pub scope: Option<String>,\n        pub username: Option<String>,\n        pub user: OutputUser,\n    }\n    /// The original query string provided to the macro. Can be reused in your codebase.\n    pub const QUERY: &str = \"select Account {**} filter .provider = <AccountProvider>$provider;\";\n}\npub mod select_user {\n    use ::gelx::exports as __g;\n    /// Execute the desired query.\n    #[cfg(feature = \"ssr\")]\n    pub async fn query(\n        client: &__g::gel_tokio::Client,\n        props: &Input,\n    ) -> ::core::result::Result<Option<Output>, __g::gel_errors::Error> {\n        client.query_single(QUERY, props).await\n    }\n    /// Compose the query as part of a larger transaction.\n    #[cfg(feature = \"ssr\")]\n    pub async fn transaction(\n        conn: &mut __g::gel_tokio::Transaction,\n        props: &Input,\n    ) -> ::core::result::Result<Option<Output>, __g::gel_errors::Error> {\n        conn.query_single(QUERY, props).await\n    }\n    #[derive(\n        ::std::fmt::Debug,\n        ::core::clone::Clone,\n        __g::serde::Serialize,\n        __g::serde::Deserialize,\n        __g::typed_builder::TypedBuilder\n    )]\n    #[cfg_attr(feature = \"ssr\", derive(__g::gel_derive::Queryable))]\n    pub struct Input {\n        #[builder(setter(into))]\n        pub slug: String,\n    }\n    impl __g::gel_protocol::query_arg::QueryArgs for Input {\n        fn encode(\n            &self,\n            encoder: &mut __g::gel_protocol::query_arg::Encoder,\n        ) -> core::result::Result<(), __g::gel_errors::Error> {\n            let map = __g::gel_protocol::named_args! {\n                \"slug\" => self.slug.clone(),\n            };\n            map.encode(encoder)\n        }\n    }\n    #[derive(\n        ::std::fmt::Debug,\n        ::core::clone::Clone,\n        __g::serde::Serialize,\n        __g::serde::Deserialize\n    )]\n    #[cfg_attr(feature = \"ssr\", derive(__g::gel_derive::Queryable))]\n    pub struct Output {\n        pub id: __g::uuid::Uuid,\n        pub name: Option<String>,\n        pub bio: Option<String>,\n        pub slug: String,\n    }\n    /// The original query string provided to the macro. Can be reused in your codebase.\n    pub const QUERY: &str = \"select User {\\n\\tid,\\n  name,\\n  bio,\\n  slug,\\n} filter .slug = <str>$slug;\";\n}\n",
  "additional.rs": "//! This file is generated by `gelx generate`.\n//! It is not intended for manual editing.\n//! To update it, run `gelx generate`.\n#![cfg_attr(rustfmt, rustfmt_skip)]\n#![allow(unused)]\n#![allow(unused_qualifications)]\n#![allow(clippy::all)]\nuse super::*;\n#[derive(\n    ::std::fmt::Debug,\n    ::core::clone::Clone,\n    ::core::marker::Copy,\n    __g::serde::Serialize,\n    __g::serde::Deserialize,\n    __g::strum::AsRefStr,\n    __g::strum::Display,\n    __g::strum::EnumString,\n    __g::strum::EnumIs,\n    __g::strum::FromRepr,\n    __g::strum::IntoStaticStr\n)]\n#[cfg_attr(feature = \"ssr\", derive(__g::gel_derive::Queryable))]\n#[strum(crate = \"__g::strum\")]\npub enum Awesomeness {\n    Very,\n    Somewhat,\n    NotReally,\n}\nimpl ::core::convert::From<Awesomeness> for __g::gel_protocol::value::Value {\n    fn from(value: Awesomeness) -> Self {\n        __g::gel_protocol::value::Value::Enum(value.as_ref().into())\n    }\n}\n#[derive(\n    ::std::fmt::Debug,\n    ::core::clone::Clone,\n    ::core::marker::Copy,\n    __g::serde::Serialize,\n    __g::serde::Deserialize,\n    __g::strum::AsRefStr,\n    __g::strum::Display,\n    __g::strum::EnumString,\n    __g::strum::EnumIs,\n    __g::strum::FromRepr,\n    __g::strum::IntoStaticStr\n)]\n#[cfg_attr(feature = \"ssr\", derive(__g::gel_derive::Queryable))]\n#[strum(crate = \"__g::strum\")]\npub enum Smartness {\n    #[serde(rename = \"low\")]\n    #[strum(serialize = \"low\")]\n    Low,\n    #[serde(rename = \"mid\")]\n    #[strum(serialize = \"mid\")]\n    Mid,\n    #[serde(rename = \"genius\")]\n    #[strum(serialize = \"genius\")]\n    Genius,\n}\nimpl ::core::convert::From<Smartness> for __g::gel_protocol::value::Value {\n    fn from(value: Smartness) -> Self {\n        __g::gel_protocol::value::Value::Enum(value.as_ref().into())\n    }\n}\n",
  "default.rs": "//! This file is generated by `gelx generate`.\n//! It is not intended for manual editing.\n//! To update it, run `gelx generate`.\n#![cfg_attr(rustfmt, rustfmt_skip)]\n#![allow(unused)]\n#![allow(unused_qualifications)]\n#![allow(clippy::all)]\nuse super::*;\nmod account {\n    use super::*;\n}\n#[derive(\n    ::std::fmt::Debug,\n    ::core::clone::Clone,\n    ::core::marker::Copy,\n    __g::serde::Serialize,\n    __g::serde::Deserialize,\n    __g::strum::AsRefStr,\n    __g::strum::Display,\n    __g::strum::EnumString,\n    __g::strum::EnumIs,\n    __g::strum::FromRepr,\n    __g::strum::IntoStaticStr\n)]\n#[cfg_attr(feature = \"ssr\", derive(__g::gel_derive::Queryable))]\n#[strum(crate = \"__g::strum\")]\npub enum AccountProvider {\n    Github,\n}\nimpl ::core::convert::From<AccountProvider> for __g::gel_protocol::value::Value {\n    fn from(value: AccountProvider) -> Self {\n        __g::gel_protocol::value::Value::Enum(value.as_ref().into())\n    }\n}\nmod email {\n    use super::*;\n}\nmod location {\n    use super::*;\n}\n#[derive(\n    ::std::fmt::Debug,\n    ::core::clone::Clone,\n    __g::serde::Serialize,\n    __g::serde::Deserialize\n)]\npub struct Position(pub i32);\n#[cfg(feature = \"ssr\")]\nimpl __g::gel_protocol::queryable::Queryable for Position {\n    type Args = <i32 as __g::gel_protocol::queryable::Queryable>::Args;\n    fn decode(\n        decoder: &__g::gel_protocol::queryable::Decoder,\n        args: &Self::Args,\n        buf: &[u8],\n    ) -> Result<Self, __g::gel_protocol::errors::DecodeError> {\n        Ok(Self(i32::decode(decoder, args, buf)?))\n    }\n    fn check_descriptor(\n        ctx: &__g::gel_protocol::queryable::DescriptorContext,\n        type_pos: __g::gel_protocol::descriptors::TypePos,\n    ) -> Result<Self::Args, __g::gel_protocol::queryable::DescriptorMismatch> {\n        __g::check_scalar(\n            ctx,\n            type_pos,\n            __g::uuid::Uuid::from_bytes([\n                20u8, 41u8, 255u8, 176u8, 65u8, 247u8, 17u8, 240u8, 182u8, 41u8, 237u8,\n                62u8, 152u8, 170u8, 52u8, 22u8,\n            ]),\n            \"default::Position\",\n        )?;\n        Ok(())\n    }\n}\nimpl ::core::convert::From<Position> for __g::gel_protocol::value::Value {\n    fn from(value: Position) -> Self {\n        value.0.into()\n    }\n}\nimpl ::core::convert::From<Position> for i32 {\n    fn from(value: Position) -> Self {\n        value.0\n    }\n}\nimpl ::core::convert::From<i32> for Position {\n    fn from(value: i32) -> Self {\n        Position(value)\n    }\n}\nimpl ::std::ops::Deref for Position {\n    type Target = i32;\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\nimpl ::std::ops::DerefMut for Position {\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        &mut self.0\n    }\n}\nmod project {\n    use super::*;\n}\nmod relationship {\n    use super::*;\n}\n#[derive(\n    ::std::fmt::Debug,\n    ::core::clone::Clone,\n    ::core::marker::Copy,\n    __g::serde::Serialize,\n    __g::serde::Deserialize,\n    __g::strum::AsRefStr,\n    __g::strum::Display,\n    __g::strum::EnumString,\n    __g::strum::EnumIs,\n    __g::strum::FromRepr,\n    __g::strum::IntoStaticStr\n)]\n#[cfg_attr(feature = \"ssr\", derive(__g::gel_derive::Queryable))]\n#[strum(crate = \"__g::strum\")]\npub enum RelationshipType {\n    Follow,\n    Block,\n    Mute,\n}\nimpl ::core::convert::From<RelationshipType> for __g::gel_protocol::value::Value {\n    fn from(value: RelationshipType) -> Self {\n        __g::gel_protocol::value::Value::Enum(value.as_ref().into())\n    }\n}\n#[derive(\n    ::std::fmt::Debug,\n    ::core::clone::Clone,\n    ::core::marker::Copy,\n    __g::serde::Serialize,\n    __g::serde::Deserialize,\n    __g::strum::AsRefStr,\n    __g::strum::Display,\n    __g::strum::EnumString,\n    __g::strum::EnumIs,\n    __g::strum::FromRepr,\n    __g::strum::IntoStaticStr\n)]\n#[cfg_attr(feature = \"ssr\", derive(__g::gel_derive::Queryable))]\n#[strum(crate = \"__g::strum\")]\npub enum Role {\n    None,\n    Editor,\n    Moderator,\n    Admin,\n    Owner,\n}\nimpl ::core::convert::From<Role> for __g::gel_protocol::value::Value {\n    fn from(value: Role) -> Self {\n        __g::gel_protocol::value::Value::Enum(value.as_ref().into())\n    }\n}\nmod simple {\n    use super::*;\n}\nmod team {\n    use super::*;\n}\nmod user {\n    use super::*;\n}\nmod wallet {\n    use super::*;\n}\n"
}

----- stderr -----
