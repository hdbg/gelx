---
source: crates/gelx_cli/src/main.rs
info:
  program: gelx
  args:
    - generate
    - "--json"
---
success: true
exit_code: 0
----- stdout -----
{
  "mod.rs": "//! This file is generated by `gelx generate`.\n//! It is not intended for manual editing.\n//! To update it, run `gelx generate`.\n#![cfg_attr(rustfmt, rustfmt_skip)]\n#![allow(unused)]\n#![allow(unused_qualifications)]\n#![allow(clippy::all)]\nuse ::gelx::exports as __g;\npub use default::*;\n#[path = \"additional.rs\"]\npub mod additional;\n#[path = \"default.rs\"]\npub mod default;\npub mod insert_location {\n    use ::gelx::exports as __g;\n    /// Execute the desired query.\n    #[cfg(feature = \"ssr\")]\n    pub async fn query(\n        client: &__g::gel_tokio::Client,\n        props: &Input,\n    ) -> ::core::result::Result<Output, __g::gel_errors::Error> {\n        client.query_required_single(QUERY, props).await\n    }\n    /// Compose the query as part of a larger transaction.\n    #[cfg(feature = \"ssr\")]\n    pub async fn transaction(\n        conn: &mut __g::gel_tokio::Transaction,\n        props: &Input,\n    ) -> ::core::result::Result<Output, __g::gel_errors::Error> {\n        conn.query_required_single(QUERY, props).await\n    }\n    #[derive(Debug, Clone, __g::serde::Serialize, __g::serde::Deserialize)]\n    #[cfg_attr(\n        feature = \"ssr\",\n        derive(__g::typed_builder::TypedBuilder, __g::gel_derive::Queryable)\n    )]\n    pub struct Input {\n        #[cfg_attr(feature = \"ssr\", builder(setter(into)))]\n        pub point: __g::Geometry,\n        #[cfg_attr(feature = \"ssr\", builder(setter(into)))]\n        pub area: __g::Geography,\n    }\n    impl __g::gel_protocol::query_arg::QueryArgs for Input {\n        fn encode(\n            &self,\n            encoder: &mut __g::gel_protocol::query_arg::Encoder,\n        ) -> core::result::Result<(), __g::gel_errors::Error> {\n            let map = __g::gel_protocol::named_args! {\n                \"point\" => self.point.clone(), \"area\" => self.area.clone(),\n            };\n            map.encode(encoder)\n        }\n    }\n    #[derive(Debug, Clone, __g::serde::Serialize, __g::serde::Deserialize)]\n    #[cfg_attr(feature = \"ssr\", derive(__g::gel_derive::Queryable))]\n    pub struct Output {\n        pub point: __g::Geometry,\n        pub area: __g::Geography,\n    }\n    /// The original query string provided to the macro. Can be reused in your codebase.\n    pub const QUERY: &str = \"with NewLocation := (insert Location {\\n\\tpoint := <ext::postgis::geometry>$point,\\n\\tarea := <ext::postgis::geography>$area,\\n})\\nselect NewLocation {\\n\\tpoint,\\n\\tarea,\\n};\";\n}\npub mod insert_user {\n    use ::gelx::exports as __g;\n    /// Execute the desired query.\n    #[cfg(feature = \"ssr\")]\n    pub async fn query(\n        client: &__g::gel_tokio::Client,\n        props: &Input,\n    ) -> ::core::result::Result<Output, __g::gel_errors::Error> {\n        client.query_required_single(QUERY, props).await\n    }\n    /// Compose the query as part of a larger transaction.\n    #[cfg(feature = \"ssr\")]\n    pub async fn transaction(\n        conn: &mut __g::gel_tokio::Transaction,\n        props: &Input,\n    ) -> ::core::result::Result<Output, __g::gel_errors::Error> {\n        conn.query_required_single(QUERY, props).await\n    }\n    #[derive(Debug, Clone, __g::serde::Serialize, __g::serde::Deserialize)]\n    #[cfg_attr(\n        feature = \"ssr\",\n        derive(__g::typed_builder::TypedBuilder, __g::gel_derive::Queryable)\n    )]\n    pub struct Input {\n        #[cfg_attr(feature = \"ssr\", builder(setter(into)))]\n        pub name: String,\n        #[cfg_attr(feature = \"ssr\", builder(setter(into)))]\n        pub bio: String,\n        #[cfg_attr(feature = \"ssr\", builder(setter(into)))]\n        pub slug: String,\n    }\n    impl __g::gel_protocol::query_arg::QueryArgs for Input {\n        fn encode(\n            &self,\n            encoder: &mut __g::gel_protocol::query_arg::Encoder,\n        ) -> core::result::Result<(), __g::gel_errors::Error> {\n            let map = __g::gel_protocol::named_args! {\n                \"name\" => self.name.clone(), \"bio\" => self.bio.clone(), \"slug\" => self\n                .slug.clone(),\n            };\n            map.encode(encoder)\n        }\n    }\n    #[derive(Debug, Clone, __g::serde::Serialize, __g::serde::Deserialize)]\n    #[cfg_attr(feature = \"ssr\", derive(__g::gel_derive::Queryable))]\n    pub struct Output {\n        pub id: __g::uuid::Uuid,\n        pub name: Option<String>,\n        pub bio: Option<String>,\n        pub slug: String,\n    }\n    /// The original query string provided to the macro. Can be reused in your codebase.\n    pub const QUERY: &str = \"with NewUser := (insert User {\\n  name := <str>$name,\\n  bio := <str>$bio,\\n  slug := <str>$slug,\\n})\\nselect NewUser {\\n  id,\\n  name,\\n  bio,\\n  slug,\\n};\\n\";\n}\npub mod remove_user {\n    use ::gelx::exports as __g;\n    /// Execute the desired query.\n    #[cfg(feature = \"ssr\")]\n    pub async fn query(\n        client: &__g::gel_tokio::Client,\n        props: &Input,\n    ) -> ::core::result::Result<Option<Output>, __g::gel_errors::Error> {\n        client.query_single(QUERY, props).await\n    }\n    /// Compose the query as part of a larger transaction.\n    #[cfg(feature = \"ssr\")]\n    pub async fn transaction(\n        conn: &mut __g::gel_tokio::Transaction,\n        props: &Input,\n    ) -> ::core::result::Result<Option<Output>, __g::gel_errors::Error> {\n        conn.query_single(QUERY, props).await\n    }\n    #[derive(Debug, Clone, __g::serde::Serialize, __g::serde::Deserialize)]\n    #[cfg_attr(\n        feature = \"ssr\",\n        derive(__g::typed_builder::TypedBuilder, __g::gel_derive::Queryable)\n    )]\n    pub struct Input {\n        #[cfg_attr(feature = \"ssr\", builder(setter(into)))]\n        pub id: __g::uuid::Uuid,\n    }\n    impl __g::gel_protocol::query_arg::QueryArgs for Input {\n        fn encode(\n            &self,\n            encoder: &mut __g::gel_protocol::query_arg::Encoder,\n        ) -> core::result::Result<(), __g::gel_errors::Error> {\n            let map = __g::gel_protocol::named_args! {\n                \"id\" => self.id.clone(),\n            };\n            map.encode(encoder)\n        }\n    }\n    #[derive(Debug, Clone, __g::serde::Serialize, __g::serde::Deserialize)]\n    #[cfg_attr(feature = \"ssr\", derive(__g::gel_derive::Queryable))]\n    pub struct Output {\n        pub id: __g::uuid::Uuid,\n    }\n    /// The original query string provided to the macro. Can be reused in your codebase.\n    pub const QUERY: &str = \"delete User filter .id = <uuid>$id;\\n\";\n}\npub mod select_user {\n    use ::gelx::exports as __g;\n    /// Execute the desired query.\n    #[cfg(feature = \"ssr\")]\n    pub async fn query(\n        client: &__g::gel_tokio::Client,\n        props: &Input,\n    ) -> ::core::result::Result<Option<Output>, __g::gel_errors::Error> {\n        client.query_single(QUERY, props).await\n    }\n    /// Compose the query as part of a larger transaction.\n    #[cfg(feature = \"ssr\")]\n    pub async fn transaction(\n        conn: &mut __g::gel_tokio::Transaction,\n        props: &Input,\n    ) -> ::core::result::Result<Option<Output>, __g::gel_errors::Error> {\n        conn.query_single(QUERY, props).await\n    }\n    #[derive(Debug, Clone, __g::serde::Serialize, __g::serde::Deserialize)]\n    #[cfg_attr(\n        feature = \"ssr\",\n        derive(__g::typed_builder::TypedBuilder, __g::gel_derive::Queryable)\n    )]\n    pub struct Input {\n        #[cfg_attr(feature = \"ssr\", builder(setter(into)))]\n        pub slug: String,\n    }\n    impl __g::gel_protocol::query_arg::QueryArgs for Input {\n        fn encode(\n            &self,\n            encoder: &mut __g::gel_protocol::query_arg::Encoder,\n        ) -> core::result::Result<(), __g::gel_errors::Error> {\n            let map = __g::gel_protocol::named_args! {\n                \"slug\" => self.slug.clone(),\n            };\n            map.encode(encoder)\n        }\n    }\n    #[derive(Debug, Clone, __g::serde::Serialize, __g::serde::Deserialize)]\n    #[cfg_attr(feature = \"ssr\", derive(__g::gel_derive::Queryable))]\n    pub struct Output {\n        pub id: __g::uuid::Uuid,\n        pub name: Option<String>,\n        pub bio: Option<String>,\n        pub slug: String,\n    }\n    /// The original query string provided to the macro. Can be reused in your codebase.\n    pub const QUERY: &str = \"select User {\\n\\tid,\\n  name,\\n  bio,\\n  slug,\\n} filter .slug = <str>$slug;\";\n}\n",
  "additional.rs": "//! This file is generated by `gelx generate`.\n//! It is not intended for manual editing.\n//! To update it, run `gelx generate`.\n#![cfg_attr(rustfmt, rustfmt_skip)]\n#![allow(unused)]\n#![allow(unused_qualifications)]\n#![allow(clippy::all)]\nuse super::*;\n#[derive(Debug, Clone, Copy, __g::serde::Serialize, __g::serde::Deserialize)]\n#[cfg_attr(\n    feature = \"ssr\",\n    derive(\n        __g::gel_derive::Queryable,\n        __g::strum::AsRefStr,\n        __g::strum::Display,\n        __g::strum::EnumString,\n        __g::strum::EnumIs,\n        __g::strum::FromRepr,\n        __g::strum::IntoStaticStr\n    )\n)]\npub enum Awesomeness {\n    Very,\n    Somewhat,\n    NotReally,\n}\n#[derive(Debug, Clone, Copy, __g::serde::Serialize, __g::serde::Deserialize)]\n#[cfg_attr(\n    feature = \"ssr\",\n    derive(\n        __g::gel_derive::Queryable,\n        __g::strum::AsRefStr,\n        __g::strum::Display,\n        __g::strum::EnumString,\n        __g::strum::EnumIs,\n        __g::strum::FromRepr,\n        __g::strum::IntoStaticStr\n    )\n)]\npub enum Smartness {\n    #[serde(rename = \"low\")]\n    #[cfg_attr(feature = \"ssr\", strum(serialize = \"low\"))]\n    Low,\n    #[serde(rename = \"mid\")]\n    #[cfg_attr(feature = \"ssr\", strum(serialize = \"mid\"))]\n    Mid,\n    #[serde(rename = \"genius\")]\n    #[cfg_attr(feature = \"ssr\", strum(serialize = \"genius\"))]\n    Genius,\n}\n",
  "default.rs": "//! This file is generated by `gelx generate`.\n//! It is not intended for manual editing.\n//! To update it, run `gelx generate`.\n#![cfg_attr(rustfmt, rustfmt_skip)]\n#![allow(unused)]\n#![allow(unused_qualifications)]\n#![allow(clippy::all)]\nuse super::*;\n#[derive(Debug, Clone, Copy, __g::serde::Serialize, __g::serde::Deserialize)]\n#[cfg_attr(\n    feature = \"ssr\",\n    derive(\n        __g::gel_derive::Queryable,\n        __g::strum::AsRefStr,\n        __g::strum::Display,\n        __g::strum::EnumString,\n        __g::strum::EnumIs,\n        __g::strum::FromRepr,\n        __g::strum::IntoStaticStr\n    )\n)]\npub enum AccountProvider {\n    Github,\n}\n#[derive(Debug, Clone, Copy, __g::serde::Serialize, __g::serde::Deserialize)]\n#[cfg_attr(\n    feature = \"ssr\",\n    derive(\n        __g::gel_derive::Queryable,\n        __g::strum::AsRefStr,\n        __g::strum::Display,\n        __g::strum::EnumString,\n        __g::strum::EnumIs,\n        __g::strum::FromRepr,\n        __g::strum::IntoStaticStr\n    )\n)]\npub enum RelationshipType {\n    Follow,\n    Block,\n    Mute,\n}\n#[derive(Debug, Clone, Copy, __g::serde::Serialize, __g::serde::Deserialize)]\n#[cfg_attr(\n    feature = \"ssr\",\n    derive(\n        __g::gel_derive::Queryable,\n        __g::strum::AsRefStr,\n        __g::strum::Display,\n        __g::strum::EnumString,\n        __g::strum::EnumIs,\n        __g::strum::FromRepr,\n        __g::strum::IntoStaticStr\n    )\n)]\npub enum Role {\n    None,\n    Editor,\n    Moderator,\n    Admin,\n    Owner,\n}\n"
}

----- stderr -----
