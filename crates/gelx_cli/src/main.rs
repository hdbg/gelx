use std::fs;
use std::io;
use std::io::Write;
use std::path::PathBuf;

use clap::Parser;
use gelx_core::GelxCoreError;
use gelx_core::GelxCoreResult;
use gelx_core::GelxMetadata;
use gelx_core::generate_enums;
use gelx_core::generate_query_token_stream;
use gelx_core::get_descriptor;
use gelx_core::prettify;
use similar::ChangeTag;
use similar::TextDiff;

/// A CLI for generating typed Rust code from Gel queries
#[derive(Parser, Debug)]
#[clap(author, version, about, long_about = None)]
struct Cli {
	#[clap(subcommand)]
	command: Commands,

	/// Optional working directory to run the command from.
	#[clap(long, value_parser = clap::value_parser!(PathBuf), global = true)]
	cwd: Option<PathBuf>,
}

#[derive(Parser, Debug)]
enum Commands {
	/// Generates Rust code from the crate in the current directory.
	Generate {
		/// Print the generated code to stdout instead of writing to a file.
		#[clap(long)]
		stdout: bool,
	},
	/// Checks if the generated Rust code is up-to-date
	Check,
}

#[tokio::main]
async fn main() -> GelxCoreResult<()> {
	let cli = Cli::parse();

	let current_dir = std::env::current_dir()?;

	// Change current directory if --cwd is provided
	if let Some(path) = &cli.cwd {
		let absolute_path = current_dir.join(path);

		if !absolute_path.is_dir() {
			eprintln!(
				"Error: Invalid --cwd path: {} is not a directory or does not exist.",
				path.display()
			);

			std::process::exit(1);
		}

		std::env::set_current_dir(absolute_path)?;
		eprintln!("Running from directory: {}", path.display());
	}

	// Load metadata from Cargo.toml or gelx.toml in the current (potentially
	// changed) directory
	let current_dir = std::env::current_dir()?;
	let metadata = GelxMetadata::try_new(current_dir)?;

	match cli.command {
		Commands::Generate { stdout } => handle_generate(&metadata, stdout).await,
		Commands::Check => handle_check(&metadata).await,
	}
}

async fn handle_generate(metadata: &GelxMetadata, to_stdout: bool) -> GelxCoreResult<()> {
	eprintln!("Generating code...");
	let generated_code = generate_all_queries_code(metadata).await?;

	if to_stdout {
		let mut stdout = io::stdout();
		stdout.write_all(generated_code.as_bytes())?;
		stdout.flush()?;
		eprintln!("Successfully printed generated code to stdout.");
	} else {
		if let Some(parent) = metadata.output.parent() {
			fs::create_dir_all(parent)?;
		}

		fs::write(&metadata.output, &generated_code)?;
		eprintln!(
			"Successfully wrote generated code to {}",
			metadata.output.display()
		);
	}

	Ok(())
}

async fn handle_check(metadata: &GelxMetadata) -> GelxCoreResult<()> {
	eprintln!("Checking code...");
	let generated_code = generate_all_queries_code(metadata).await?;

	if !metadata.output.exists() {
		eprintln!(
			"Error: Output file {} does not exist. Run `gelx generate` first.",
			metadata.output.display()
		);
		std::process::exit(1);
	}

	let existing_code = fs::read_to_string(&metadata.output)?;

	if generated_code != existing_code {
		let diff = TextDiff::from_lines(&existing_code, &generated_code);

		for change in diff.iter_all_changes() {
			let sign = match change.tag() {
				ChangeTag::Delete => "-",
				ChangeTag::Insert => "+",
				ChangeTag::Equal => " ",
			};
			eprintln!("{sign}{change}");
		}

		std::process::exit(1);
	}

	eprintln!("Generated code is up-to-date.");
	Ok(())
}

async fn generate_all_queries_code(metadata: &GelxMetadata) -> GelxCoreResult<String> {
	if !metadata.queries.is_dir() {
		return Err(GelxCoreError::Custom(format!(
			"Queries directory not found: {}",
			metadata.queries.display()
		)));
	}

	let mut all_generated_code = String::new();

	all_generated_code.push_str("//! This file is @generated by gelx.\n");
	all_generated_code.push_str("//! It is not intended for manual editing.\n");
	all_generated_code.push_str("//! To update it, run `gelx generate`.\n");
	all_generated_code.push_str("#![cfg_attr(rustfmt, rustfmt_skip)]\n");
	all_generated_code.push_str("#![allow(unused)]\n");
	all_generated_code.push_str("#![allow(unused_qualifications)]\n");
	all_generated_code.push_str("#![allow(clippy::all)]\n");

	let enum_code = generate_enums(metadata, false).await?;
	all_generated_code.push_str(&enum_code.to_string());

	let mut entries = fs::read_dir(&metadata.queries)?.collect::<Result<Vec<_>, _>>()?;
	entries.sort_by_key(fs::DirEntry::path);

	for entry in entries {
		let path = entry.path();

		if path.is_file() && path.extension().is_some_and(|ext| ext == "edgeql") {
			let query_content = fs::read_to_string(&path)?;
			let file_stem = path.file_stem().unwrap_or_default().to_string_lossy();
			// Use metadata for naming conventions if available, otherwise defaults.
			let module_name = file_stem.to_string();

			eprintln!("Processing query: {}", path.display());
			let descriptor = get_descriptor(&query_content, metadata).await?;
			let token_stream = generate_query_token_stream(
				&descriptor,
				&module_name,
				&query_content,
				metadata,
				false,
			)?;

			all_generated_code.push_str(&token_stream.to_string());
			all_generated_code.push('\n');
		}
	}

	if all_generated_code.lines().count() <= 2 {
		// Only comments
		eprintln!(
			"Warning: No .edgeql files found in {}. Generated file will be empty.",
			metadata.queries.display()
		);
	}

	Ok(prettify(&all_generated_code)?)
}

#[cfg(test)]
mod tests {
	use std::process::Command;
	use std::process::Stdio;

	use super::*;

	const CRATE_DIR: &str = env!("CARGO_MANIFEST_DIR");

	fn cli() -> Command {
		// TODO: fix this breaks on CI as it needs the build to be run first I think
		// Command::new(insta_cmd::get_cargo_bin("gelx"))
		Command::new("gelx")
	}

	#[test]
	fn generate_stdout() {
		let path = PathBuf::from(CRATE_DIR).join("../../examples/gelx_example");
		insta_cmd::assert_cmd_snapshot!(
			cli()
				.arg("generate")
				.arg("--stdout")
				.current_dir(path)
				.stderr(Stdio::null())
		);
	}
}
